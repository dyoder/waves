= Waves

An open source framework for building web-applications with Ruby.

Waves is ... Full-featured and thread-safe. Compact and extensible. Configuration *and* convention. RESTful but also Magical (very important).

Waves is powered by ... Rack and Mongrel (HTTP server), Sequel or Filebase (storage), AutoCode (code reloading), LiveConsole (hot patching).

== Links

* {Web Site}[http://rubywaves.com/]
  * {Tutorial}[http://rubywaves.com/tutorial]
  * {Contributors}[http://rubywaves.com/credits]
* {Source}[http://github.com/dyoder/waves]
* {Issue tracker}[http://waves.lighthouseapp.com]
* {Mailing List}[http://groups.google.com/group/rubywaves/]
* {RubyForge}[http://rubyforge.org/projects/waves/]
* {RDoc}[http://waves.rubyforge.org/]

== Bootstrap!

=== Get Waves

  # latest release from Rubyforge
  gem install waves
  
  # relatively recent gem build from master on GitHub
  gem install dyoder-waves --source=http://gems.github.com
  
  # get the framework source
  git clone git://github.com/dyoder/waves.git
  cd waves
  rake setup # install gem dependencies needed to work from source

  
=== Generate an application

  # working from gems
  waves ~/dev/web/killer_app
  
  # working from source
  ./bin/waves ~/dev/killer_app

This generates a default application in the target directory.  The application module's name is the constant-cased version of the target directory basename, in this case KillerApp.  

=== Configure basic settings

Configure your database connection using the +database+ attribute in <tt>configurations/development.rb</tt>.  The default ORM is currently Sequel, but there are other ORM layers in the works.  The value of +database+ is used with {Sequel.connect}[http://sequel.rubyforge.org/classes/Sequel.html#M000069].  Sequel's current documentation seems to favor a URL-style argument, but we have been getting along fine with a hash.

  database :adapter => 'sqlite', :database => 'killer_app.db'

Create the initial db schema.  You can create a {Sequel migration}[http://sequel.rubyforge.org/classes/Sequel/Migration.html] with:

  rake schema:migration name=users
  vi schema/migrations/001_users.rb

And you can run migrations with:

  rake schema:migrate
  
  # or with a version number
  rake schema:migrate version=1


=== Mappings

The Waves equivalent to routes are mappings.  A mapping consists of a request-matching construct and an arbitrary block.  When a request matches a mapping, Waves runs that block.  In the simplest case, you do all the response work in the block, a la {Sinatra}[http://sinatrarb.com/Home].  The standard Waves application also offers an MVC infrastructure, spelled with a silent R for Resource.

The application keeps its mappings in <tt>configurations/mapping.rb</tt>.  It mixes in some RESTy mappings as a helpful starter:

* Waves::Mapping::PrettyUrls::RestRules
* Waves::Mapping::PrettyUrls::GetRules

Here's an example of a mapping adapted from GetRules:

  # define some regexes
  model_regex = '([\w\-]+)'
  name_regex = '([\w\-\_\.\+\@]+)'; 
  
  # display the given resource for the given model
  path %r{^/#{model_regex}/#{name_regex}/?$}, :method => :get do | model, name |
    resource( model ) do
      controller { find( name ) }  |  view { |data| show( model => data ) }
    end
  end

For convenience, we defined regexes to match the model and name components of a path.  The +path+ method registers a block for use with requests where the path matches the supplied regex and where the HTTP method is GET.  The parameters passed to the block are the MatchData captures, i.e. the strings caught by +model_regex+ and +name_regex+.

So a GET to "/user/vyvyan", for example, will pass "user" and "vyvyan" to the block as the model and name parameters, respectively.

The +resource+ method uses its argument to determine which controller and view will be instantiated for work done in its block.  Thus using the example above, we instantiate KillerApp::Controllers::User when we call +controller+ and KillerApp::Views::User when we call +view+.

The "|" character, as seen between the controller and view invocations, is a method that causes the result of the controller block to be passed into the view block.  Thus, in the controller block, an instance of Controllers::User calls its +find+ method with "vyvyan" as the argument.  The resulting object is passed to an instance of Views::User, which calls <tt>show( "user" => <some user object>)</tt>.  

Any undefined method in a View attempts to render a template named after the method, with its argument turned into instance variables.  In the present example, the view will try to render <tt>templates/user/show.mab</tt> (or show.erb), providing it with @user = <the user object>.  You can, of course, define methods in the View to override this.

For more complete documentation, see Waves::Mapping.

== Running an application

  cd my_app
  waves-server -h 0.0.0.0 -p 3001 -c production --daemon
  
There are also rake tasks for running a cluster:

  rake cluster:start mode=production # reads the Production config for ports.

You can work in an irb-based console:

  waves-console # or bin/waves-console


== Where the Wavy Things Are

A Waves application consists of a Ruby module structured with internal namespaces.  Thus:

   KillerApp::Configurations
   KillerApp::Controllers
   KillerApp::Helpers
   KillerApp::Models
   KillerApp::Views

As you might have guessed, the working classes live in these namespaces.  E.g. <tt>KillerApp::Models::User</tt>.  

The otherwise harsh birth and life of these working classes is softened by {AutoCode}[http://autocode.rubyforge.org/], a sort of mini-Industrial Revolution for Ruby constants.  The Waves framework uses AutoCode to automatically generate controllers, models, views, etc. the first time each constant is needed by the application.  Waves looks for a file in a path that corresponds to the namespaced constant name.  If such exists, it gets loaded.  If not, Waves creates the class or module from sensible defaults.  

For example, when a Waves application encounters <tt>KillerApp::Views::MonkeyShines</tt> for the first time, it tries to load it from <tt>./views/monkey_shines.rb</tt>.  If that file does not exist, the app creates <tt>KillerApp::Views::MonkeyShines</tt> as a dupe of <tt>Waves::Views::Base</tt>.  

The result is that you only need to define models, views, etc. <i>when the default behavior stops meeting your needs.</i>


=== Directory structure

  ./
    bin/
      waves-console
      waves-server
    configurations/    # auto_load defined for Mapping; (auto_load || auto_create) anything else
    controllers/       # (auto_load || auto_create)
    helpers/           # (auto_load || auto_create)
    lib/               
      application.rb   # Application requires and includes, plus your configuration needs.
      tasks/           # .rb and .rake files in here are automatically required by the main Rakefile
    models/            # (auto_load || auto_create)
    schema/            
      migrations/      
    startup.rb         # Framework setup.  Don't touch.
    templates/         # Views expect templates to live here.
    views/             # (auto_load || auto_create)



